package com.testlangpp.parser;

import java.util.*;
import com.testlangpp.model.*;

parser code {:
  // Main execution logic moved to Main.java
:};

//   Terminals (Tokens)

terminal CONFIG, BASE_URL, LET, TEST, EXPECT, STATUS;
terminal GET, POST, PUT, DELETE;
terminal HEADER, BODY, CONTAINS;
terminal LBRACE, RBRACE, EQUALS, SEMI;
terminal String IDENT, STRING;
terminal Integer NUMBER;


//   Nonterminals (Grammar Rules)
  
non terminal Program program;
non terminal Config config_block;
non terminal List<Variable> variable_list;
non terminal Variable variable_decl;
non terminal List<TestBlock> test_list;
non terminal TestBlock test_block;
non terminal RequestStatement request_stmt;
non terminal List<RequestHeader> header_list;
non terminal RequestHeader header_decl;
non terminal RequestBody body_decl;
non terminal List<Assertion> assertion_list;
non terminal Assertion assertion_stmt;

// start symbol

start with program;

//Grammer Rules

/* Main program structure */
program ::= 
    config_block:c variable_list:v test_list:t
    {: RESULT = new Program(c, v, t); :}
  | variable_list:v test_list:t
    {: RESULT = new Program(null, v, t); :}
  ;

// config block

config_block ::=
    CONFIG LBRACE BASE_URL EQUALS STRING:url SEMI header_list:h RBRACE
    {: RESULT = new Config(url, h); :}
  ;

// Variables

variable_list ::=
    /* empty */
    {: RESULT = new ArrayList<Variable>(); :}
  | variable_list:list variable_decl:v
    {: list.add(v); RESULT = list; :}
  ;

variable_decl ::=
    LET IDENT:name EQUALS STRING:value SEMI
    {: RESULT = new Variable(name, value); :}
  | LET IDENT:name EQUALS NUMBER:value SEMI
    {: RESULT = new Variable(name, value); :}
  ;

// Test Blocks

test_list ::=
    test_block:t
    {: 
      List<TestBlock> list = new ArrayList<TestBlock>();
      list.add(t);
      RESULT = list;
    :}
  | test_list:list test_block:t
    {: list.add(t); RESULT = list; :}
  ;

test_block ::=
    TEST IDENT:name LBRACE request_stmt:req assertion_list:asserts RBRACE
    {: RESULT = new TestBlock(name, req, asserts); :}
  ;

// HTTP Requests

request_stmt ::=
    GET STRING:path SEMI
    {: RESULT = new RequestStatement("GET", path, new ArrayList<RequestHeader>(), null); :}
  | DELETE STRING:path SEMI
    {: RESULT = new RequestStatement("DELETE", path, new ArrayList<RequestHeader>(), null); :}
  | POST STRING:path SEMI
    {: RESULT = new RequestStatement("POST", path, new ArrayList<RequestHeader>(), null); :}
  | PUT STRING:path SEMI
    {: RESULT = new RequestStatement("PUT", path, new ArrayList<RequestHeader>(), null); :}
  | POST STRING:path LBRACE header_list:h body_decl:b RBRACE SEMI
    {: RESULT = new RequestStatement("POST", path, h, b); :}
  | PUT STRING:path LBRACE header_list:h body_decl:b RBRACE SEMI
    {: RESULT = new RequestStatement("PUT", path, h, b); :}
  | GET STRING:path EXPECT STATUS EQUALS NUMBER:code
    {: 
      System.err.println("Missing semicolon after request");
      RESULT = new RequestStatement("GET", path, new ArrayList<RequestHeader>(), null);
    :}
  ;
//Headers

header_list ::=
    /* empty */
    {: RESULT = new ArrayList<RequestHeader>(); :}
  | header_list:list header_decl:h
    {: list.add(h); RESULT = list; :}
  ;

header_decl ::=
    HEADER STRING:key EQUALS STRING:value SEMI
    {: RESULT = new RequestHeader(key, value); :}
  ;

// Body

body_decl ::=
    /* empty */
    {: RESULT = null; :}
  | BODY EQUALS STRING:content SEMI
    {: RESULT = new RequestBody(content); :}
  | BODY EQUALS NUMBER:content SEMI
    {: 
      System.err.println("Body must be a string");
      RESULT = null;
    :}
  ;

// Assertions

assertion_list ::=
    assertion_stmt:a1 assertion_stmt:a2
    {: 
      List<Assertion> list = new ArrayList<Assertion>();
      list.add(a1);
      list.add(a2);
      RESULT = list;
    :}
  | assertion_list:list assertion_stmt:a
    {: list.add(a); RESULT = list; :}
  ;

assertion_stmt ::=
    EXPECT STATUS EQUALS NUMBER:code SEMI
    {: RESULT = new Assertion(code); :}
  | EXPECT STATUS EQUALS STRING:code SEMI
    {: 
      System.err.println("Status must be integer");
      RESULT = new Assertion(0); // dummy value
    :}
  | EXPECT HEADER STRING:key EQUALS STRING:value SEMI
    {: RESULT = new Assertion(key, value, true); :}
  | EXPECT HEADER STRING:key CONTAINS STRING:value SEMI
    {: RESULT = new Assertion(key, value, false); :}
  | EXPECT BODY CONTAINS STRING:value SEMI
    {: RESULT = new Assertion(value); :}
  ;